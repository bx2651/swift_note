swift提供了5个不同的访问级别:

* open:允许在定义实体的模块、其他模块中访问，允许其他模块继承、重写，只能用在类、类成员
* public：允许在定义实体的模块、其他模块中访问，不允许继承、重写
* internal:只允许在定义实体的模块中访问，不允许其他模块访问
* fileprivate:只允许在定义实体的源文件访问
* private:只允许在定义实体的封闭声明中访问

绝大部分实体默认为internal级别

### 访问级别的使用准则：

* 一个实体不可以被更低访问级别的实体定义（前者的访问级别要大于后者）：
	* 变量、常量类型>=变量、常量
	* 参数类型、返回值类型>=函数
	* 父类>=子类
	* 父协议>=子协议
	* 原类型>=typealias
	* 原始值类型、关联值类型>=枚举类型
	* 定义类型A时用到的其他类型>=类型A
* 元组类型的访问级别是元组所有成员类型最低的那个
* 泛型类型的访问级别时类型的访问级别以及所有泛型类型参数的访问级别中最低的那个
* 成员嵌套类型：类型的访问级别会影响成员（属性、方法、下标、初始化器）、嵌套类型的默认访问级别
	* 一般情况下，类型为private或fileprivate，那么成员/嵌套类型的默认也是private或fileprivate
	* 一般情况下，类型为internal或public,那么成员/嵌套类型的默认是internal
* 直接在全局作用域定义的private等价于fileprivate
* getter,setter默认自动接收他们所属环境的访问级别
	* 可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限
* 初始化器：
	* 如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须显式提供public的无参初始化器
	* required初始化器必须跟它所属类拥有相同的访问级别
	* 如果结构体有private、fileprivate的存储实例属性，那么它的成员初始化器也是private、fileprivate,否则默认就是internal
* enum:不允许给每个case单独设置访问级别
* 协议：协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别，协议实现的访问级别必须大于等于类型的访问级别或协议的访问级别
* 扩展：在同一文件中的扩展，可以写成类似多个部分的类型声明
	* 在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它
	* 在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它